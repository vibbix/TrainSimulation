package edu.wit.comp2000.group23.application3.Utilities;/** * A class that implements the ADT queue by using an expandable * circular array with one unused location. * * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.0 */public final class ArrayQueue<T> {    private T[] queue; // Circular array of queue entries and one unused location    private int frontIndex;    private int backIndex;    private int count;    private boolean initialized = false;    private static final int DEFAULT_CAPACITY = 50;    private static final int MAX_CAPACITY = 10000;    public ArrayQueue() {        this(DEFAULT_CAPACITY);    } // end default constructor    public ArrayQueue(int initialCapacity) {        checkCapacity(initialCapacity);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] tempQueue = (T[]) new Object[initialCapacity + 1];        queue = tempQueue;        frontIndex = 0;        backIndex = initialCapacity;        count = 0;        initialized = true;    } // end constructor    //  < Implementations of the queue operations go here. >    public void enqueue(T newEntry) {        checkInitialization();        ensureCapacity();        backIndex = (backIndex + 1) % queue.length;        queue[backIndex] = newEntry;        count++;    } // end enqueue    public T getFront() {        checkInitialization();        if (isEmpty())            throw new EmptyQueueException();        else            return queue[frontIndex];    } // end getFront    public T dequeue() {        checkInitialization();        if (isEmpty())            throw new EmptyQueueException();        else {            T front = queue[frontIndex];            queue[frontIndex] = null;            frontIndex = (frontIndex + 1) % queue.length;            count--;            return front;        } // end if    } // end dequeue    // Version 4.0// Doubles the size of the array queue if it is full// Precondition: checkInitialization has been called.    private void ensureCapacity() {        if (frontIndex == ((backIndex + 2) % queue.length)) // if array is full,        {                                                   // double size of array            T[] oldQueue = queue;            int oldSize = oldQueue.length;            int newSize = 2 * oldSize;            if (newSize > MAX_CAPACITY && oldSize < MAX_CAPACITY) {                newSize = MAX_CAPACITY;            }            checkCapacity(newSize);            // The cast is safe because the new array contains null entries            @SuppressWarnings("unchecked")            T[] tempQueue = (T[]) new Object[newSize];            queue = tempQueue;            for (int index = 0; index < oldSize - 1; index++) {                queue[index] = oldQueue[frontIndex];                frontIndex = (frontIndex + 1) % oldSize;            } // end for            frontIndex = 0;            backIndex = oldSize - 2;        } // end if    } // end ensureCapacity    // Version 4.0    public boolean isEmpty() {        return (count == 0);    } // end isEmpty    public void clear() {        for (int i = 0; i < queue.length; i++) {            queue[i] = null;        }        frontIndex = 0;        backIndex = queue.length;        count = 0;    }    private void checkInitialization() {        if (!initialized) {            throw new SecurityException("Queue not initialized");        }    }    private void checkCapacity(int capacity) {        if (capacity > MAX_CAPACITY)            throw new IllegalArgumentException("Capacity cannot expand beyond " + MAX_CAPACITY + " entries.");        else if (capacity < 1) {            throw new IllegalArgumentException("Capacity cannot be less than 1.");        }    }} // end ArrayQueue